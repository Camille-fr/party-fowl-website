<!-- Target: src/partials/home/home-03-menu-carousel-desktop.html | Desktop 1440px -->
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Menu Highlights – Party Flow</title>
  <style>
    @font-face{
      font-family:"AshwoodCondensed";
      src:url("../../assets/fonts/Ashwood Condensed WF Regular.ttf") format("truetype");
      font-display:swap;
    }
    @font-face{
      font-family:"Newslab";
      src:url("../../assets/fonts/Latinotype - Newslab.otf") format("opentype");
      font-display:swap;
    }
    @font-face{
      font-family:"AshwoodExtraBold";
      src:url("../../assets/fonts/Ashwood Extra Bold WF Regular.ttf") format("truetype");
      font-display:swap;
    }
    @font-face{
      font-family:"Buttergone";
      src:url("../../assets/fonts/Buttergone OTF.otf") format("opentype");
      font-weight:400;
      font-style:normal;
      font-display:swap;
    }

    :root{
      color-scheme: dark;
      /* Shared background variables copied from slide 02 */
      --bg-deep: #010915;
      --bg-mid:  #03172b;
      --bg-highlight: #06263d;
      --accent-red:  #f40012;
      --accent-teal: #7dc3b8;
      --noise-texture: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 160 160'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' seed='12'/%3E%3C/filter%3E%3Crect width='160' height='160' filter='url(%23n)' opacity='0.25'/%3E%3C/svg%3E");

      /* Ink color unified with slide 02 */
      --ink:#ffffff;

      /* Layout breathing room top/bottom only (left/right must be flush) */
      --vPadTop: 0px;

      /* Carousel geometry */
      --capH: 138px;
      --titleH: clamp(78px, 5vw, 112px); /* taller slot to avoid clipping top/bottom */
      --descH: 68px;       /* fixed slot for description start alignment */
      --captionGap: 12px;  /* space between desc and title */
      --panelW: clamp(300px, 28vw, 480px);
      --sep: 2px; /* thin black divider between panels */
      --leftSafe: clamp(360px, 38vw, 620px);
      /* Progress bar area height at bottom */
      --progAreaH: clamp(54px, 7vh, 86px);
      --bottomPad: clamp(56px, 7vh, 128px);
    }

    *{ box-sizing:border-box; }
    html,body{ height:auto; }
    html{ scroll-behavior:smooth; background: transparent; }
    body{
      margin:0;
      color:#fff;
      line-height:1.5;
      min-height:0;
      overflow:hidden; /* we keep hidden to avoid stray scrollbars in iframe */
      position:relative;
      isolation:isolate;
      background: transparent;
    }

    /* Fixed overlays copied from slide 02 for identical look */
    body::before{ display:none; }
    body::after{ display:none; }

    .slide{
      position:relative;
      width:100%;
      padding: var(--vPadTop) 0 var(--bottomPad);
      overflow:hidden;
      background: transparent;
    }
    /* FULL-BLEED carousel: flush left & right; airy top/bottom via inset */
    .track{
      position:relative;
      display:flex;
      width:100%;
      overflow-x:auto;
      overflow-y:hidden;
      -webkit-overflow-scrolling: touch;
      padding:0;
      margin:0;
      scroll-behavior:auto;
      scrollbar-width:none;
      cursor: grab;
      user-select:none;
      /* Ensure the carousel container has no background of its own */
      background: transparent;
      /* Keep horizontal scroll self-contained; let vertical scroll bubble */
      overscroll-behavior-x: contain;
      overscroll-behavior-y: auto;
    }
    .track::-webkit-scrollbar{ display:none; }
    .track.dragging{ cursor: grabbing; }

    .panel{
      position:relative;
      flex:0 0 var(--panelW);
      height:auto;
      aspect-ratio: 2 / 3.15;
      overflow:hidden;
      /* Transparent so the single shared slide background shows through */
      background: transparent;
      border-radius:0; /* square angles */
      /* Isolate paint to reduce large repaints during scroll */
      contain: paint;
    }
    .panelLink{
      position:absolute;
      inset:0;
      display:block;
      z-index:3;
      color:inherit;
      text-decoration:none;
      border-radius:0;
      outline:none;
    }
    .panelLink:focus-visible{
      box-shadow:
        inset 0 0 0 2px rgba(3,11,22,1),
        inset 0 0 0 4px rgba(125,195,184,0.85);
    }
    /* Thin black divider between photos */
    .panel:not(:last-child)::after{
      content:"";
      position:absolute;
      top:0; right:0;
      width:var(--sep);
      height:100%;
      background:#000; /* fine black bar */
      pointer-events:none;
    }

    .media{
      position:absolute;
      inset:0; /* occupy full panel; caption will overlay on top of media */
      overflow:hidden;
      /* No extra background — keep it transparent to avoid a second background layer */
      background: transparent;
      z-index: 0;
    }
    .media img{
      width:100%;
      height:100%;
      display:block;
      object-fit:cover;
      /* Default: black & white */
      filter: grayscale(1) contrast(1.05);
      transform: scale(1);
      transition: transform .24s ease, filter .24s ease;
      will-change: transform, filter;
    }
    /* Hover: color + gentle scale for a satisfying emphasis */
    .panel:hover .media img,
    .panel.is-active .media img,
    .panel:focus-within .media img{
      filter: grayscale(0) saturate(1.08) contrast(1.06);
      transform: scale(1.06);
    }
    /* While dragging the carousel, avoid hover animations */
    .track.dragging .panel .media img{ transition: none; }
    .track.dragging .panelLink{ pointer-events: none; }
    .media::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        radial-gradient(120% 90% at 40% 40%, transparent 34%, rgba(0,0,0,.52) 78%),
        linear-gradient(180deg, rgba(0,0,0,.06), rgba(0,0,0,.64));
      pointer-events:none;
    }

    .caption{
      position:absolute;
      left:0; right:0; bottom:0;
      min-height: var(--capH);
      padding: clamp(26px, 3vw, 36px) 20px clamp(32px, 4vw, 44px);
      display:grid;
      grid-template-rows: var(--titleH) var(--descH);
      align-content: end; /* pin rows to bottom */
      justify-items: center;
      row-gap: var(--captionGap);
      background: transparent; /* overlay effect handled by ::before */
      z-index: 2;
      pointer-events: none; /* keep drag smooth over text */
    }
    /* Soft blurred gradient under the caption for readability without a hard edge */
    .caption::before{
      content:"";
      position:absolute;
      left:0; right:0; bottom:0;
      height: max(52%, calc(var(--capH) + 54px));
      background:
        linear-gradient(180deg,
          rgba(0, 0, 0, 0.00) 0%,
          rgba(0, 0, 0, 0.28) 35%,
          rgba(0, 0, 0, 0.46) 65%,
          rgba(0, 0, 0, 0.70) 100%);
      /* Remove heavy backdrop blur for smoother scrolling */
      /* Fade the top edge smoothly to avoid a hard cutoff */
      mask-image: linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,0));
      -webkit-mask-image: linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,0));
      z-index: -1;
      pointer-events:none;
    }
    .capTitle{
      grid-row: 1;
      height: var(--titleH);
      /* allow up to two lines, centered */
      position: relative;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2; /* WebKit/Chromium */
      line-clamp: 2; /* modern fallback */
      text-align: center;
      margin: 10px 18px 4px;
      max-width: calc(100% - 36px);
      font-family:"Buttergone", system-ui, -apple-system, Segoe UI, Roboto, Arial;
      letter-spacing:.06em;
      text-transform: none;
      font-size: clamp(22px, 2.8vw, 32px);
      line-height:1.14;
      color: #ffebee;
      /* No surrounding pill/background/border */
      padding: 2px 0 2px;
      border: 0;
      border-radius: 0;
      background: transparent;
      box-shadow: none;
      overflow: hidden; /* enforce 2-line clamp */
      /* Do not split words; wrap to next line instead */
      word-break: normal;
      overflow-wrap: normal;
      hyphens: none;
      /* Neon red text-only glow */
      transition: text-shadow .18s ease, color .18s ease;
      text-shadow:
        0 0 2px rgba(255, 64, 64, 0.75),
        0 0 6px rgba(255, 64, 64, 0.70),
        0 0 12px rgba(244, 0, 18, 0.60),
        0 0 18px rgba(244, 0, 18, 0.45);
    }
    /* Hover: switch neon from red to white, slightly stronger */
    .panel:hover .capTitle,
    .panel.is-active .capTitle,
    .panel:focus-within .capTitle{
      color: #ffffff;
      text-shadow:
        0 0 2px rgba(255,255,255,0.85),
        0 0 6px rgba(255,255,255,0.80),
        0 0 12px rgba(255,255,255,0.70),
        0 0 18px rgba(255,255,255,0.55);
    }
    .capDesc{
      grid-row: 2;
      height: var(--descH);
      align-self: stretch;
      font-family:"Newslab", system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size: clamp(13px, 1.4vw, 15px);
      letter-spacing:.02em;
      color: rgba(255,255,255,.74);
      line-height:1.45;
      display:-webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow:hidden;
      text-shadow: 0 1px 10px rgba(0,0,0,.55);
    }

    /* Fixed left overlay text (does NOT move) */
    .fixedLeft{
      position:absolute;
      top:0; left:0;
      height:100%;
      width:var(--leftSafe);
      display:flex;
      align-items:flex-start; /* place content at top */
      justify-content:flex-start;
      padding: clamp(36px, 3vw, 64px) 34px 0 42px; /* move the copy down inside the media band */
      z-index: 5;
      pointer-events:none;
    }
    .fixedLeft::before{
      content:"";
      position:absolute;
      top: var(--vPadTop);
      left: 0;
      right: 0;
      bottom: calc(var(--progAreaH) + var(--bottomPad) + 12px);
      background:
        linear-gradient(90deg,
          rgba(0,0,0,.84) 0%,
          rgba(0,0,0,.70) 36%,
          rgba(0,0,0,.38) 66%,
          rgba(0,0,0,0) 100%);
      z-index:-1;
    }
    .titleBox{
      max-width: 560px;
      transform: translateY(0); /* lowered via padding instead of extra offset */
      /* Allow pointer events for title hover animation while keeping the overlay non-blocking */
      pointer-events: auto;
    }
    .menu-title{ margin:6px 0 12px 0; position:relative; z-index:6; text-align:left; }
    /* Replace block glow with per-letter glow; hide former block */
    .menu-title::before{ display:none; }
    /* Removed red underline per request */
    .menu-title::after{ display:none; }
    .menu-title-line{
      display:block;
      font-family:"AshwoodCondensed", serif;
      font-size: clamp(56px, 7.8vw, 118px); /* bigger for prominence */
      letter-spacing:.12em;
      line-height:.90;
      text-transform:uppercase;
      color: rgba(255,255,255,0.96);
      text-shadow: 0 2px 0 rgba(0,0,0,.75), 0 0 10px rgba(244, 0, 18, 0.35);
      overflow: visible;
      will-change: transform;
      white-space: nowrap; /* avoid wrapping letters to a new line */
    }
    /* Slightly smaller for the second line to create hierarchy */
    .menu-title-line:nth-child(2){ font-size: clamp(48px, 7.2vw, 104px); }
    /* Per-letter hover styling, same spirit as slide 02 */
    .mn-letter{
      display:inline-block;
      position:relative;
      padding:0 0.02em;
      transform: translateZ(0) scale(var(--scale, 1)) translateY(var(--dy, 0px)) rotate(var(--rot, 0deg));
      transform-origin: 50% 82%;
      transition: transform 0s, text-shadow 0.15s ease, filter 0.15s ease;
      will-change: transform, filter;
      z-index: var(--z, 0);
      text-shadow:
        0 12px 24px rgba(0, 0, 0, 0.85),
        0 0 calc(max(0px, (var(--scale, 1) - 1) * 36px)) rgba(244, 0, 18, 0.60),
        0 0 calc(max(0px, (var(--scale, 1) - 1) * 20px)) rgba(244, 0, 18, 0.22);
    }
    /* Neon red per-letter glow behind each letter */
    .mn-letter::before{
      content:"";
      position:absolute;
      left:50%; top:52%;
      transform: translate(-50%, -50%) scale(calc(1 + (var(--scale, 1) - 1) * 1.4));
      width: 1.22em; height: 1.08em;
      pointer-events:none;
      border-radius: 50%;
      background:
        radial-gradient(48% 46% at 50% 50%, rgba(244, 0, 18, 0.95) 0%, rgba(244, 0, 18, 0.45) 40%, rgba(244, 0, 18, 0) 72%);
      filter: blur(14px) saturate(120%);
      opacity: calc(var(--glow, 0) * 0.95);
      mix-blend-mode: screen;
      z-index: -1;
      transition: opacity .18s ease-out, filter .20s ease-out, transform .20s ease-out;
    }
    .menu-title-line:hover .mn-letter::before{
      filter: blur(18px) saturate(135%);
      opacity: calc(var(--glow, 0) * 1.15);
    }
    .menu-title-line:hover .mn-letter{ filter:saturate(1.05); }
    @media (prefers-reduced-motion: reduce){
      .mn-letter{ transition:none; transform:none !important; }
      .menu-title::before{ animation:none; }
      .mn-letter::before{ filter: blur(10px); }
    }

    @keyframes neonPulse{
      0% { opacity: 0.78; filter: blur(24px) saturate(112%); }
      50%{ opacity: 0.90; filter: blur(26px) saturate(120%); }
      100%{ opacity: 0.82; filter: blur(25px) saturate(116%); }
    }
    .titleBox .sub{
      font-family:"Newslab", system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size: clamp(16px, 1.4vw, 22px); /* smaller subtitle */
      margin:2px 0 12px 0;
      color: rgba(242,239,231,.92);
      text-shadow: 0 2px 14px rgba(0,0,0,.55);
      font-style: italic;
    }

    /* CTA under the title: premium pill, matching site buttons with a carousel vibe */
    .menu-cta{
      --glow: rgba(244, 0, 18, 0.68);
      --border: rgba(244, 0, 18, 0.95);
      font-family: "Newslab", "Nunito Sans", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding: 12px 22px;
      min-height: 46px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: transparent;
      color:#ff1f2b;
      text-transform: uppercase;
      letter-spacing: .06em;
      font-weight: 800;
      font-size: clamp(12px, 1.05vw, 14px);
      text-decoration:none;
      box-shadow:
        0 6px 18px rgba(0,0,0,0.65),
        0 0 16px rgba(244, 0, 18, 0.56),
        0 0 36px rgba(244, 0, 18, 0.32),
        inset 0 0 12px rgba(244, 0, 18, 0.30);
      text-shadow: 0 0 10px rgba(244, 0, 18, 0.24);
      position:relative;
      overflow:hidden;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      -webkit-tap-highlight-color: transparent;
      transition: transform .16s ease, box-shadow .16s ease, letter-spacing .18s ease, border-color .16s ease, color .18s ease;
    }
    .menu-cta::before{
      content:""; position:absolute; inset:2px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.10); pointer-events:none; opacity:.85;
    }
    .menu-cta::after{
      content:""; position:absolute; inset:-30%; border-radius:999px; pointer-events:none;
      background: radial-gradient(circle at 50% 50%, rgba(244, 0, 18, 0.7), transparent 70%);
      opacity:0; filter: blur(18px); transition: opacity .22s ease, filter .22s ease;
      z-index:-1;
    }
    .menu-cta:hover{
      transform: translateY(-1px) scale(1.01);
      letter-spacing: .08em;
      border-color: rgba(255, 120, 126, 1);
      box-shadow:
        0 8px 20px rgba(0,0,0,0.55),
        0 0 22px rgba(244, 0, 18, 0.78),
        0 0 46px rgba(244, 0, 18, 0.45),
        inset 0 0 16px rgba(244, 0, 18, 0.36);
      color: #ffd5d9;
    }
    .menu-cta:hover::after{ opacity:.85; filter: blur(22px); }
    .menu-cta:active{ transform: translateY(0); }
    .menu-cta:focus{ outline: none; }
    .menu-cta:focus-visible{
      box-shadow:
        0 0 0 2px rgba(3,11,22,1),
        0 0 0 4px rgba(255, 120, 126, 0.85),
        0 14px 28px rgba(0,0,0,0.55);
    }
    .menu-cta .arrow{ display:inline-block; transition: transform .16s ease; }
    .menu-cta:hover .arrow{ transform: translateX(2px); }
    @media (prefers-reduced-motion: reduce){
      .track{ scroll-behavior:auto; }
    }
    @media (max-width: 1100px){
      :root{ --sep: 2px; --vPadTop: clamp(6px, 1vw, 10px); }
      .fixedLeft{ padding-left:28px; padding-right:28px; }
    }

    .srOnly{
      position:absolute !important;
      width:1px;height:1px;
      padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0;
    }

    /* ========================
       Neon progress indicator
       ======================== */
    .progressWrap{
      position:relative;
      height: var(--progAreaH);
      display:flex;
      align-items:center;
      justify-content:center;
      margin-top: 10px;
      pointer-events:none; /* let only the inner bar receive events */
      z-index: 6;
      background: none; /* keep the bottom area clean */
    }
    .progress{
      position:relative;
      width: min(84vw, 1200px);
      max-width: 1200px;
      height: 18px; /* slightly slimmer */
      display:flex;
      align-items:center;
      justify-content:center;
      filter: saturate(115%);
      pointer-events:auto; /* enable interactions on the bar */
    }
    .progress-rail{
      position:relative;
      width:100%;
      height: 2px; /* slimmer rail */
      border-radius: 999px;
      background:
        linear-gradient(90deg, rgba(125,195,184,0.10), rgba(125,195,184,0.20), rgba(125,195,184,0.10));
      box-shadow:
        0 0 10px rgba(125,195,184,0.25),
        0 0 20px rgba(125,195,184,0.15);
      overflow:hidden;
    }
    .progress-knob{
      position:absolute; top:50%; left:0; transform: translate(-50%, -50%);
      width: 14px; height: 14px; /* smaller knob */
      border-radius: 999px;
      background:
        radial-gradient(45% 45% at 50% 50%, #7DC3B8, rgba(125,195,184,0.65) 60%, rgba(125,195,184,0.0) 72%);
      box-shadow:
        0 0 10px rgba(125,195,184,0.85),
        0 0 22px rgba(125,195,184,0.55),
        0 0 36px rgba(125,195,184,0.35);
      pointer-events:auto; /* allow dragging the knob */
      will-change: transform;
    }
    /* subtle shimmer along the rail */
    .progress-rail::after{
      content:""; position:absolute; inset:0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.35), transparent);
      transform: translateX(-120%);
      animation: progShimmer 4s ease-in-out infinite;
      opacity:.25; pointer-events:none;
    }
    @keyframes progShimmer{
      0%{ transform: translateX(-120%); }
      55%{ transform: translateX(120%); }
      100%{ transform: translateX(120%); }
    }
  </style>
</head>

<body>
  <main class="slide" aria-label="Menu Highlights">
    <!-- FIXED LEFT TEXT -->
    <aside class="fixedLeft" aria-hidden="false">
      <div class="titleBox" aria-label="Menu highlights text">
        <div class="menu-title">
          <span class="menu-title-line">MENU</span>
          <span class="menu-title-line">HIGHLIGHTS</span>
        </div>
        <p class="sub">Scroll to explore menu categories.</p>
        <a class="menu-cta" href="../../pages/menu.html" target="_top" aria-label="Explore full menu">Explore Full Menu <span class="arrow" aria-hidden="true">→</span></a>
      </div>
    </aside>

    <!-- FULL-BLEED INFINITE CAROUSEL -->
    <section class="track" id="menuTrack" role="list" aria-label="Carousel menu categories">
      <!-- Category cards (will be cloned by JS for infinite loop) -->

      <article class="panel" role="listitem" data-category="brunch">
        <a class="panelLink" href="../../pages/menu.html" target="_top" aria-label="Explore Brunch"></a>
        <div class="media">
          <img alt="Brunch" loading="lazy" decoding="async"
               data-src="../../assets/img/home/menu/official_Food_images/brunch/nacho-ordinary-breakfast-nachos.jpg" />
        </div>
        <div class="caption">
          <div class="capTitle">Brunch</div>
          <div class="capDesc">Late-morning legends stacked with bold spice and brunch energy.</div>
        </div>
      </article>

      <article class="panel" role="listitem" data-category="for-the-table">
        <a class="panelLink" href="../../pages/menu.html" target="_top" aria-label="Explore For the Table"></a>
        <div class="media">
          <img alt="For the Table" loading="lazy" decoding="async"
               data-src="../../assets/img/home/menu/official_Food_images/for-the-table/chips-queso.jpg" />
        </div>
        <div class="caption">
          <div class="capTitle">For the Table</div>
          <div class="capDesc">Shareable plates loaded with punchy dips for every table.</div>
        </div>
      </article>

      <article class="panel" role="listitem" data-category="soups-salads">
        <a class="panelLink" href="../../pages/menu.html" target="_top" aria-label="Explore Soups &amp; Salads"></a>
        <div class="media">
          <img alt="Soups &amp; Salads" loading="lazy" decoding="async"
               data-src="../../assets/img/home/menu/official_Food_images/soups-salads/hot-chick-caesar-salad.jpg" />
        </div>
        <div class="caption">
          <div class="capTitle">Soups &amp; Salads</div>
          <div class="capDesc">Crisp greens and smoky bowls finished with tangy heat.</div>
        </div>
      </article>

      <article class="panel" role="listitem" data-category="hot-chicken">
        <a class="panelLink" href="../../pages/menu.html" target="_top" aria-label="Explore Nashville Hot Chicken"></a>
        <div class="media">
          <img alt="Nashville Hot Chicken" loading="lazy" decoding="async"
               data-src="../../assets/img/home/menu/official_Food_images/nashville-hot-chicken/half-bird-fried.jpg" />
        </div>
        <div class="caption">
          <div class="capTitle">Nashville Hot Chicken</div>
          <div class="capDesc">Signature Nashville-level spice layered over perfectly fried chicken.</div>
        </div>
      </article>

      <article class="panel" role="listitem" data-category="handhelds">
        <a class="panelLink" href="../../pages/menu.html" target="_top" aria-label="Explore Not Hot Chicken &amp; Handhelds"></a>
        <div class="media">
          <img alt="Not Hot Chicken &amp; Handhelds" loading="lazy" decoding="async"
               data-src="../../assets/img/home/menu/official_Food_images/handhelds/cowboy-burger.jpg" />
        </div>
        <div class="caption">
          <div class="capTitle">Not Hot Chicken &amp; Handhelds</div>
          <div class="capDesc">Juicy burgers, wraps, and handhelds delivering comfort without the burn.</div>
        </div>
      </article>

      <article class="panel" role="listitem" data-category="sides">
        <a class="panelLink" href="../../pages/menu.html" target="_top" aria-label="Explore Sides"></a>
        <div class="media">
          <img alt="Sides" loading="lazy" decoding="async"
               data-src="../../assets/img/home/menu/official_Food_images/sides/fried-cheese-curds.jpg" />
        </div>
        <div class="caption">
          <div class="capTitle">Sides</div>
          <div class="capDesc">Crisp sides and creamy dips that elevate every order.</div>
        </div>
      </article>

      <article class="panel" role="listitem" data-category="tasty-treats">
        <a class="panelLink" href="../../pages/menu.html" target="_top" aria-label="Explore Tasty Treats"></a>
        <div class="media">
          <img alt="Tasty Treats" loading="lazy" decoding="async"
               data-src="../../assets/img/home/menu/official_Food_images/tasty-treats/hot-chicken-beignets.jpg" />
        </div>
        <div class="caption">
          <div class="capTitle">Tasty Treats</div>
          <div class="capDesc">Sweet endings with sugar-dusted beignets and neon glow.</div>
        </div>
      </article>

      <p class="srOnly" id="srHint">
        Drag, trackpad, or scroll to browse categories. The carousel loops infinitely.
      </p>
    </section>

    <!-- Neon turquoise progress indicator tied to carousel scroll -->
    <div class="progressWrap" aria-hidden="true">
      <div class="progress" id="menuProgress">
        <div class="progress-rail"></div>
        <div class="progress-knob" id="menuProgressKnob"></div>
      </div>
    </div>
  </main>

  <script>
    (function(){
      const track = document.getElementById('menuTrack');

      // ---------------------------
      // Local image resolver (try local, else fallback)
      // ---------------------------
      const inlineFallback = (() => {
        const svg = `
          <svg xmlns="http://www.w3.org/2000/svg" width="1200" height="1600">
            <defs>
              <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
                <stop offset="0" stop-color="#070812"/>
                <stop offset="0.55" stop-color="#0b0c14"/>
                <stop offset="1" stop-color="#05060a"/>
              </linearGradient>
              <radialGradient id="r" cx="30%" cy="22%" r="70%">
                <stop offset="0" stop-color="rgba(0,229,255,.22)"/>
                <stop offset="0.55" stop-color="rgba(124,77,255,.12)"/>
                <stop offset="1" stop-color="rgba(0,0,0,0)"/>
              </radialGradient>
            </defs>
            <rect width="100%" height="100%" fill="url(#g)"/>
            <rect width="100%" height="100%" fill="url(#r)"/>
            <g fill="rgba(242,239,231,.70)" font-family="Arial, sans-serif">
              <text x="70" y="120" font-size="44">Image placeholder</text>
              <text x="70" y="182" font-size="28" fill="rgba(242,239,231,.45)">Add ../../assets/img/home/...</text>
            </g>
          </svg>`;
        return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg.trim());
      })();

      function resolveImg(img){
        const local = img.getAttribute('data-src');
        const fb = img.getAttribute('data-fallback');

        const setInline = () => {
          img.onerror = null;
          img.src = inlineFallback;
        };

	        const setFallback = () => {
	          if (fb) {
	            img.onerror = setInline;
	            img.src = fb;
	          } else {
	            setInline();
	          }
	        };

        if (local) {
          img.onerror = setFallback;
          img.src = local;
        } else {
          setFallback();
        }
      }

      // Charger toutes les images immédiatement afin d'éviter des recalculs
      // d'intersection coûteux pendant l'animation continue.
      function resolveAllImgs(){
        Array.from(track.querySelectorAll('img[data-src]')).forEach(resolveImg);
      }
      resolveAllImgs();

      // ---------------------------
      // Drag-to-scroll
      // ---------------------------
      let isDown = false, startX = 0, startY = 0, startLeft = 0, pid = null, dragged = false;
      const DRAG_CLICK_THRESHOLD = 6;
      track.addEventListener('pointerdown', (e) => {
        if (e.pointerType === 'touch') return;
        if (auto && typeof auto.pause === 'function') auto.pause(1600);
        isDown = true;
        dragged = false;
        pid = e.pointerId;
        track.setPointerCapture(pid);
        startX = e.clientX;
        startY = e.clientY;
        startLeft = track.scrollLeft;
        track.style.scrollBehavior = 'auto';
        track.classList.add('dragging');
      });
      track.addEventListener('pointermove', (e) => {
        if(!isDown) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        if (!dragged && (Math.abs(dx) > DRAG_CLICK_THRESHOLD || Math.abs(dy) > DRAG_CLICK_THRESHOLD)) {
          dragged = true;
        }
        track.scrollLeft = startLeft - dx;
        updateProgressBar();
      });
      const endDrag = () => {
        if(!isDown) return;
        isDown = false;
        pid = null;
        // Garder un comportement instantané pour éviter des micro à-coups
        track.style.scrollBehavior = 'auto';
        track.classList.remove('dragging');
        setTimeout(() => { dragged = false; }, 0);
      };
      track.addEventListener('pointerup', endDrag);
      track.addEventListener('pointercancel', endDrag);
      track.addEventListener('pointerleave', endDrag);
      track.addEventListener('click', (e) => {
        if (!dragged) return;
        const link = e.target.closest('.panelLink');
        if (!link) return;
        e.preventDefault();
        e.stopPropagation();
        dragged = false;
      }, true);

      // ---------------------------
      // Infinite loop carousel (both directions)
      // ---------------------------
      const originalPanels = Array.from(track.querySelectorAll('.panel'));
      const n = originalPanels.length;

      const clonesBefore = originalPanels.map(p => p.cloneNode(true));
      const clonesAfter  = originalPanels.map(p => p.cloneNode(true));
      clonesBefore.forEach(p => p.dataset.clone = "before");
      clonesAfter.forEach(p => p.dataset.clone = "after");

      clonesBefore.slice().reverse().forEach(cl => track.insertBefore(cl, track.firstChild));
      clonesAfter.forEach(cl => track.appendChild(cl));

      // Charger les images dans les clones également
      resolveAllImgs();

      // Éviter les mesures layout à chaque frame: on mise en cache la largeur d'un panneau
      let panelW = 0;
      function computePanelWidth(){
        const p = track.querySelector('.panel');
        panelW = p ? p.offsetWidth : 0; // offsetWidth est suffisant et plus léger
        return panelW;
      }

      const allPanels = Array.from(track.querySelectorAll('.panel'));
      let activePanel = null;
      function updateActivePanel(){
        const w = panelW || computePanelWidth();
        if (!w) return;
        const center = track.scrollLeft + (track.clientWidth * 0.5);
        const idx = Math.max(0, Math.min(allPanels.length - 1, Math.floor(center / w)));
        const next = allPanels[idx];
        if (!next || next === activePanel) return;
        if (activePanel) activePanel.classList.remove('is-active');
        activePanel = next;
        activePanel.classList.add('is-active');
      }

      function snapToRealStart(){
        const w = panelW || computePanelWidth();
        if(!w) return;
        const peek = Math.min(160, Math.max(72, Math.round(w * 0.22)));
        const offset = Math.max(0, w - peek);
        track.scrollLeft = (w * n) + offset; // start near slide 02 with a subtle left/right peek
        updateProgressBar();
        updateActivePanel();
      }

      // Gestion du bouclage en douceur (sans écouteur scroll à chaque frame)
      function wrapIfNeeded(){
        const w = panelW || computePanelWidth();
        if(!w) return;
        const totalReal = w * n;
        const leftBoundary  = totalReal * 0.5;
        const rightBoundary = totalReal * 2.5;
        if(track.scrollLeft < leftBoundary){
          track.scrollLeft += totalReal;
        } else if(track.scrollLeft > rightBoundary){
          track.scrollLeft -= totalReal;
        }
      }

      // Keep progress/active states in sync for any scroll input (wheel, drag, touch inertia).
      let scrollRaf = 0;
      track.addEventListener('scroll', () => {
        if (scrollRaf) return;
        scrollRaf = requestAnimationFrame(() => {
          scrollRaf = 0;
          wrapIfNeeded();
          updateProgressBar();
          updateActivePanel();
        });
      }, { passive: true });

      let resizeTO = null;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTO);
        resizeTO = setTimeout(() => { computePanelWidth(); snapToRealStart(); }, 100);
      });

      // Mesure initiale + positionnement
      requestAnimationFrame(() => { computePanelWidth(); snapToRealStart(); });

      // ---------------------------
      // Gentle auto-scroll loop (only when the slide is visible)
      // ---------------------------
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const auto = {
        speed: 90, // px/sec
        raf: 0,
        last: 0,
        enabled: false,
        resumeTO: 0,
        pause(ms) {
          if (!this.enabled) return;
          stopAuto();
          if (this.resumeTO) window.clearTimeout(this.resumeTO);
          this.resumeTO = window.setTimeout(() => {
            this.resumeTO = 0;
            if (this.enabled && !prefersReducedMotion) startAuto();
          }, Math.max(0, ms | 0));
        }
      };
      if (prefersReducedMotion) auto.speed = Math.max(10, auto.speed * 0.45);
      track.style.scrollBehavior = 'auto';

      function step(dtSec){
        track.scrollLeft += auto.speed * dtSec;
        wrapIfNeeded();
        updateProgressBar();
        updateActivePanel();
      }
      function autoTick(t){
        const last = auto.last || (t - 16);
        const dtSec = Math.min(0.08, Math.max(0, (t - last) / 1000)) || (1/60);
        auto.last = t;
        step(dtSec);
        auto.raf = requestAnimationFrame(autoTick);
      }
      function startAuto(){
        if (!auto.enabled || prefersReducedMotion || auto.raf) return;
        auto.last = performance.now();
        auto.raf = requestAnimationFrame(autoTick);
      }
      function stopAuto(){
        if (auto.raf) cancelAnimationFrame(auto.raf);
        auto.raf = 0;
        auto.last = 0;
      }
      function setAutoEnabled(enabled){
        auto.enabled = !!enabled;
        if (!auto.enabled) {
          stopAuto();
          if (auto.resumeTO) window.clearTimeout(auto.resumeTO);
          auto.resumeTO = 0;
          return;
        }
        startAuto();
      }
      // Parent page toggles this based on slide visibility.
      window.__setMenuCarouselAuto = setAutoEnabled;

      document.addEventListener('visibilitychange', () => {
        if (document.hidden) stopAuto();
        else if (auto.enabled) startAuto();
      });

      // ============================
      // Progress bar sync logic
      // ============================
      const prog = {
        rail: document.querySelector('#menuProgress .progress-rail'),
        knob: document.getElementById('menuProgressKnob'),
        railW: 0,
        knobW: 0
      };
      function measureProgress(){
        if (!prog.rail) return;
        prog.railW = prog.rail.clientWidth || 0;
        prog.knobW = prog.knob ? prog.knob.offsetWidth || 0 : 0;
      }
      function normalizedProgress(){
        const w = panelW || computePanelWidth();
        if (!w || !n) return 0;
        const totalReal = w * n;
        let s = track.scrollLeft % totalReal;
        if (s < 0) s += totalReal;
        return totalReal ? (s / totalReal) : 0;
      }
      function updateProgressBar(){
        if (!prog.rail || !prog.knob) return;
        const p = Math.max(0, Math.min(1, normalizedProgress()));
        if (prog.railW <= 0 || prog.knobW <= 0) measureProgress();
        const r = prog.knobW * 0.5;
        const cx = Math.max(r, Math.min(prog.railW - r, p * prog.railW));
        prog.knob.style.left = cx.toFixed(2) + 'px';
        prog.knob.style.transform = 'translate(-50%, -50%)';
      }

      function scrollToProgress(p){
        const w = panelW || computePanelWidth();
        if (!w || !n) return;
        const totalReal = w * n;
        const base = w * n; // start of the real set after before-clones
        track.style.scrollBehavior = 'auto';
        track.scrollLeft = base + Math.max(0, Math.min(1, p)) * totalReal;
        wrapIfNeeded();
        updateProgressBar();
        updateActivePanel();
      }

      // Interactions: click & drag on progress rail/knob to scrub
      const progressEl = document.getElementById('menuProgress');
      let scrubPID = null;
      let scrubbing = false;
      function pFromEvent(ev){
        const r = prog.rail.getBoundingClientRect();
        const x = Math.max(0, Math.min(r.width, (ev.clientX - r.left)));
        return r.width ? (x / r.width) : 0;
      }
      function beginScrub(ev){
        if (!prog.rail) return;
        scrubbing = true;
        auto.pause(2000);
        const p = pFromEvent(ev);
        scrollToProgress(p);
        if (ev.pointerId != null){
          scrubPID = ev.pointerId;
          (prog.knob || progressEl).setPointerCapture(scrubPID);
        }
        ev.preventDefault();
      }
      function moveScrub(ev){
        if (!scrubbing) return;
        const p = pFromEvent(ev);
        scrollToProgress(p);
        ev.preventDefault();
      }
      function endScrub(){
        if (!scrubbing) return;
        scrubbing = false; scrubPID = null;
      }

      if (progressEl && prog.rail && prog.knob){
        // Click on rail
        prog.rail.addEventListener('pointerdown', beginScrub);
        prog.rail.addEventListener('pointermove', moveScrub);
        window.addEventListener('pointerup', endScrub);
        window.addEventListener('pointercancel', endScrub);
        // Drag knob
        prog.knob.addEventListener('pointerdown', beginScrub);
        prog.knob.addEventListener('pointermove', moveScrub);
      }
      window.addEventListener('resize', () => { measureProgress(); updateProgressBar(); }, { passive:true });

      // Initial measures and start
      measureProgress();
      updateProgressBar();
      updateActivePanel();
      // Standalone preview: keep the subtle motion on.
      const STANDALONE = (function(){ try { return window.self === window.top; } catch(_) { return true; } })();
      setAutoEnabled(STANDALONE && !prefersReducedMotion);
    })();
  </script>

  <!-- Title per-letter hover animation for two-line title (safe, no layout shift) -->
  <script>
    (function(){
      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const pointerFine = window.matchMedia('(pointer: fine)').matches;
      if (prefersReduced || !pointerFine) return;

      const lines = Array.from(document.querySelectorAll('.menu-title-line'));
      if (!lines.length) return;

      function attachWave(titleEl){
        if (!titleEl || titleEl.dataset.splitLetters === '1') return;
        titleEl.dataset.splitLetters = '1';
        const raw = titleEl.textContent || '';
        titleEl.textContent = '';
        const frag = document.createDocumentFragment();
        const letters = [];
        for (const ch of raw){
          const s = document.createElement('span');
          s.className = 'mn-letter';
          s.textContent = (ch === ' ') ? '\u00A0' : ch;
          frag.appendChild(s);
          letters.push(s);
        }
        titleEl.appendChild(frag);

        const N = letters.length;
        const state = new Array(N).fill(0).map(() => ({ s:1, dy:0, rot:0, z:0, g:0 }));
        const target= new Array(N).fill(0).map(() => ({ s:1, dy:0, rot:0, z:0, g:0 }));
        let rafId = 0, inside = false;

        function computeTargets(idx){
          const baseMaxBoost = 0.35; // softer to avoid overlap below
          const falloff = 0.92;
          const maxTilt = 2.0;
          const rect = titleEl.getBoundingClientRect();
          const headroom = Math.max(0, rect.top);
          const safety = Math.max(0.86, Math.min(1, headroom / 90));
          const maxBoost = baseMaxBoost * safety;
          for(let j=0;j<N;j++){
            const d = idx < 0 ? Infinity : Math.abs(j-idx);
            const boost = idx < 0 ? 0 : maxBoost * Math.exp(-d * falloff);
            const s = 1 + boost;
            const dy = idx < 0 ? 0 : 1.5 * Math.exp(-d * 1.08) * (boost / Math.max(0.0001, maxBoost));
            const rot = idx < 0 ? 0 : (j < idx ? -1 : 1) * maxTilt * Math.exp(-d * 0.85) * (j === idx ? 0 : 1);
            const z = 50 - (idx < 0 ? 0 : d);
            const g = idx < 0 ? 0 : Math.max(0, Math.min(1, (boost / Math.max(0.0001, maxBoost)) * 1.0));
            target[j].s=s; target[j].dy=dy; target[j].rot=rot; target[j].z=z; target[j].g=g;
          }
        }

        function animate(){
          let moving=false; const k=0.22;
          for(let j=0;j<N;j++){
            const st=state[j], tg=target[j];
            st.s += (tg.s - st.s) * k;
            st.dy+= (tg.dy- st.dy)* k;
            st.rot+=(tg.rot-st.rot)* k;
          st.z  += (tg.z - st.z) * k;
          st.g  += (tg.g - st.g) * 0.28;
          const el = letters[j];
          el.style.setProperty('--scale', st.s.toFixed(3));
          el.style.setProperty('--dy', st.dy.toFixed(2)+'px');
          el.style.setProperty('--rot', st.rot.toFixed(2)+'deg');
          el.style.setProperty('--z', String(st.z.toFixed(0)));
          el.style.setProperty('--glow', st.g.toFixed(3));
            if (Math.abs(tg.s-st.s)>0.002 || Math.abs(tg.dy-st.dy)>0.02 || Math.abs(tg.rot-st.rot)>0.02){ moving=true; }
          }
          if(moving||inside){ rafId=requestAnimationFrame(animate); } else { rafId=0; }
        }
        function ensure(){ if(!rafId) rafId=requestAnimationFrame(animate); }

        function nearestIndexFromClientX(x){
          let best=-1, bestD=Infinity; for(let j=0;j<N;j++){
            const r = letters[j].getBoundingClientRect();
            const cx = r.left + r.width/2; const d = Math.abs(x-cx);
            if(d<bestD){ bestD=d; best=j; }
          } return best;
        }

        titleEl.addEventListener('pointerenter', () => { inside=true; });
        titleEl.addEventListener('pointermove', (e) => { inside=true; computeTargets(nearestIndexFromClientX(e.clientX)); ensure(); });
        titleEl.addEventListener('pointerleave', () => { inside=false; computeTargets(-1); ensure(); });

        computeTargets(-1);
      }

      lines.forEach(attachWave);
    })();
  </script>

</body>
</html>
